# coding=utf-8
# Copyright 2022 The ML Fairness Gym Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# Lint as: python2, python3
"""ML Fairness gym loan environment.
This environment is meant to be a hello-world example to the gym as well as
serve as a template for writing future environments.
In each step step, the agent decides whether to accept or reject an application.
Applicant features are generated by a mixture model which also determines the
likelihood of defaulting.
"""

from __future__ import absolute_import
from __future__ import division
from __future__ import print_function

import copy
import time
from typing import Dict, Optional, Text, List, Mapping, Tuple, Any
import attr
import gymnasium as gym
from gymnasium import spaces
from gymnasium.utils import seeding
import numpy as np

import math
import numba
from numba import njit

from fairness_gymnasium.envs import core, multinomial

NUM_CLIENTS = 40
NUM_CLIENTS_PER_GROUP = 20
NUM_CLASSES = 5
BENEFIT_RATE = 1.3 * 0.1
LOSS_RATE = 1.0 * 0.1

@njit
def numba_seed(seed):
    np.random.seed(seed)


@njit
def calculate_total_variation_distance(dist1, dist2):
    tv_distance = 0.5 * np.sum(np.abs(dist1 - dist2))
    return tv_distance

@attr.s
class Params(core.Params):
    """Lending parameters."""

    n_groups = attr.ib(default=2)  # type: int
    # Probability of being in each class in the mixture model.
    class_probs = attr.ib(factory=lambda: [0.0, 0.2, 0.3, 0.3, 0.2,\
                                           0.0, 0.2, 0.3, 0.3, 0.2])  # type: List[float]
    # Probability of repaying a loan for each class.
    repay_probs = attr.ib(default=(0.1, 0.3, 0.5, 0.7, 0.9))  # type: Tuple[float, ...]
    # Mass to shift from one class to another.
    dynamic_rate = attr.ib(default=0.05)  # type: float
    # The max number of steps in an episode.
    max_timesteps = attr.ib(default=50) # type: int
    burn_in = attr.ib(default=0) # type: int
    render = attr.ib(default=False) # type: bool
    exp_name = attr.ib(default="default") # type: str


@attr.s(cmp=False)
class State(core.State):
    """Lending state."""

    # Parameters.
    params = attr.ib()  # type: Params

    credit_scores = attr.ib()  # type: np.ndarray

    loan_approved = attr.ib()  # type: np.ndarray

    loan_defaulted = attr.ib()  # type: np.ndarray
    
    loan_repaid = attr.ib()  # type: np.ndarray

    credit_thresholds = attr.ib() # type: np.ndarray

    inequality = attr.ib()  # type: float


@njit
def _random_choice_nb(class_probs):
    cumulative_distribution = np.cumsum(class_probs)
    cumulative_distribution /= cumulative_distribution[-1]
    uniform_samples = np.random.rand(NUM_CLIENTS_PER_GROUP)
    samples = np.searchsorted(cumulative_distribution, uniform_samples, side="right")
    return samples


@njit
def _sample_scores(class_probs):
    samples_a = _random_choice_nb(class_probs[:NUM_CLASSES])
    samples_b = _random_choice_nb(class_probs[NUM_CLASSES:])
    samples = np.concatenate((samples_a, samples_b)).astype('int32')
    return samples


@njit
def _update_state(
    class_probs,
    repay_probs,
    dynamic_rate,
    alphas,
    credit_scores, 
    action,
):
    will_repay = np.zeros(NUM_CLIENTS).astype('int32')

    for i in range(NUM_CLIENTS):
        p = repay_probs[credit_scores[i]]
        will_repay[i] = np.random.binomial(n=1, p=p)

    group1_scores = np.sort(credit_scores[:NUM_CLIENTS_PER_GROUP])
    group2_scores = np.sort(credit_scores[NUM_CLIENTS_PER_GROUP:])
    thresholds = np.array((group1_scores[-int(action[0])], group2_scores[-int(action[1])]))
    
    resource, threshold = action[0], thresholds[0]
    loan_approved = np.zeros(NUM_CLIENTS).astype('int32')
    for i in range(NUM_CLIENTS):
        if resource == 0:
            if i == NUM_CLIENTS_PER_GROUP:
                resource = action[1]
                threshold = thresholds[1]
            continue
        if credit_scores[i] >= threshold:
            loan_approved[i] = 1
            resource -= 1

    loan_repaid    = np.logical_and(loan_approved, will_repay).astype('int32')
    loan_defaulted = np.logical_and(loan_approved, np.logical_not(will_repay)).astype('int32')

    for i in range(NUM_CLIENTS):
        offset = 0 if i < NUM_CLIENTS_PER_GROUP else NUM_CLASSES
        p = class_probs[credit_scores[i] + offset]
        if p < dynamic_rate:    # no mass to shift
            continue
        elif loan_repaid[i]:
            if credit_scores[i] < NUM_CLASSES - 1:
                class_probs[credit_scores[i] + offset] -= dynamic_rate
                class_probs[credit_scores[i] + 1 + offset] +=dynamic_rate
        elif loan_defaulted[i]:
            if credit_scores[i] > 0:
                class_probs[credit_scores[i] + offset] -= dynamic_rate
                class_probs[credit_scores[i] - 1 + offset] += dynamic_rate

    related_adv = mass_to_shift = (alphas[1]-alphas[0]) * 1.0
    if related_adv > 0:
        for i in range(NUM_CLASSES):
            if class_probs[NUM_CLASSES + i] >= mass_to_shift and mass_to_shift > 0:
                class_probs[NUM_CLASSES + i] -= mass_to_shift
                mass_to_shift = 0
            elif class_probs[NUM_CLASSES + i] >= 0 and mass_to_shift > 0:
                mass_to_shift -= class_probs[NUM_CLASSES + i]
                class_probs[NUM_CLASSES + i] = 0
            if mass_to_shift <= 0:
                if i == NUM_CLASSES - 1:
                    mass = 1.0 - np.array(class_probs[NUM_CLASSES:]).sum()
                    class_probs[NUM_CLASSES + i] += mass
                    break
                else: 
                    class_probs[NUM_CLASSES + i + 1] += related_adv
                    break
    elif related_adv < 0:
        related_adv = mass_to_shift = -related_adv
        for i in range(NUM_CLASSES-1, -1, -1):
            if class_probs[NUM_CLASSES + i] >= mass_to_shift and mass_to_shift > 0:
                class_probs[NUM_CLASSES + i] -= mass_to_shift
                mass_to_shift = 0
            elif class_probs[NUM_CLASSES + i] >= 0 and mass_to_shift > 0:
                mass_to_shift -= class_probs[NUM_CLASSES + i]
                class_probs[NUM_CLASSES + i] = 0
            if mass_to_shift <= 0:
                if i == 0: 
                    mass = 1.0 - np.array(class_probs[NUM_CLASSES:]).sum()
                    class_probs[NUM_CLASSES + i] += mass
                    break
                else: 
                    class_probs[NUM_CLASSES + i - 1] += related_adv
                    break

    return thresholds, loan_approved, loan_defaulted, loan_repaid


class LendingEnv(gym.Env):

    def __init__(self, params = None, env_cfgs= None):
        if params is None:
            params = Params()

        assert (len(params.class_probs) == params.n_groups*NUM_CLASSES)
        assert (len(params.repay_probs) == NUM_CLASSES)

        if env_cfgs is not None:
            self.alphas = (env_cfgs['alpha1'], env_cfgs['alpha2'])
            self.betas = (env_cfgs['beta1'], env_cfgs['beta2'])
            params.incident_rates = env_cfgs['rate1'] + env_cfgs['rate2']
        else:
            self.alphas = (0.0, 0.0)
            self.betas = (0.0, 0.0)
        
        self.observation_space = spaces.Box(
            low=-np.inf,
            high=np.inf,
            shape=(params.n_groups * NUM_CLASSES,),
            dtype=np.float32
        )
        self.action_space = spaces.Box(
            low=-1.0,
            high=1.0,
            shape=(params.n_groups*2,),
            dtype=np.float32
        )
        self.reward_space = spaces.Box(
            low=-np.inf,
            high=np.inf,
            shape=(params.n_groups,),
            dtype=np.float32
        )
        self.initial_params = copy.deepcopy(params)
        self.max_timesteps = params.max_timesteps
        self.timestep = 0
        self._state_init()
        self.burn_in = params.burn_in

    def _state_init(self):
        params = copy.deepcopy(self.initial_params)
        n_groups = params.n_groups
        params.class_probs = np.array(params.class_probs).tolist()
        self.state = State(
            params=params,
            credit_scores=np.zeros(NUM_CLIENTS, dtype='int32'),
            loan_approved=np.zeros(NUM_CLIENTS, dtype='int32'),
            loan_defaulted=np.zeros(NUM_CLIENTS, dtype='int32'),
            loan_repaid=np.zeros(NUM_CLIENTS, dtype='int32'),
            credit_thresholds=np.zeros(n_groups, dtype='int32'),
            inequality=0.0)

    def _is_truncated(self):
        """Never returns true because there is no end case to this environment."""
        return self.timestep >= self.max_timesteps

    def _step_impl(self, state, action):
        # sample the credit scores for new clients in this round
        params = state.params
        state.credit_scores = _sample_scores(np.array(params.class_probs))
        # update the tier distribution based on the credit scores in this round
        state.credit_thresholds, state.loan_approved, \
        state.loan_defaulted, state.loan_repaid \
            =  _update_state(
                params.class_probs,
                params.repay_probs,
                params.dynamic_rate,
                self.alphas,
                state.credit_scores, 
                action
            )
        return state
    
    def _get_observable_state(self):
        return np.array(self.state.params.class_probs, dtype=np.float32)
    
    def _reward_fn(self):
        state = self.state

        dist1, dist2 = state.params.class_probs[:NUM_CLASSES], state.params.class_probs[NUM_CLASSES:]
        dist1 = np.array(dist1).astype('float64')
        dist2 = np.array(dist2).astype('float64')
        inequality_term = 1.0 * calculate_total_variation_distance(dist1, dist2)

        defaulted_term = -LOSS_RATE * np.array((np.sum(state.loan_defaulted[:NUM_CLIENTS_PER_GROUP]), \
            np.sum(state.loan_defaulted[NUM_CLIENTS_PER_GROUP:])))
        repaid_term = BENEFIT_RATE * np.array((np.sum(state.loan_repaid[:NUM_CLIENTS_PER_GROUP]), \
            np.sum(state.loan_repaid[NUM_CLIENTS_PER_GROUP:])))
        tot_rew = defaulted_term + repaid_term
        tot_rew[1] = tot_rew[1] + (self.betas[1]-self.betas[0]) * 1.0

        rate = np.array(state.params.class_probs)
        rate0 = (rate[:NUM_CLASSES] * np.arange(NUM_CLASSES)).mean()
        rate1 = (rate[NUM_CLASSES:] * np.arange(NUM_CLASSES)).mean()
        self.rew_info = {
            'max_rate': np.max((rate0, rate1)),
            'min_rate': np.min((rate0, rate1)),
            'occurr': state.credit_scores.mean(),
            'miss': np.sum(state.loan_defaulted),
            'alloc': np.sum(state.loan_approved),
            'inequality_term': inequality_term,
            'tot_rew': tot_rew,
        }

        return tot_rew.astype(np.float32)
    
    @staticmethod
    @njit
    def _process_action(
        raw_action,
        n_groups,
        n_loan_allowed,
    ):
        action = raw_action.reshape(n_groups, 2).sum(1) / 4.0
        action = 0.5 * (1+np.sin(np.pi * action))
        action = np.round(np.multiply(action, n_loan_allowed))
        return action

    def seed(self, seed = None):
        """Sets the seed for this env's random number generator."""
        rng, seed = seeding.np_random(seed)
        numba_seed(seed)
        return [seed]

    def reset(
            self,
            *,
            seed = None,
            options = None,
    ):
        """Resets the environment."""
        if seed is not None:
            self.seed(seed)

        self.timestep = 0
        self._state_init()
        n_groups = self.initial_params.n_groups
        n_loan_allowed = NUM_CLIENTS_PER_GROUP
        obs = self._get_observable_state()
        # burn in a few steps for generating the initial state
        for _ in range(self.burn_in):
            self.state.credit_scores = _sample_scores(np.array(self.state.params.class_probs))
            action = self.action_space.sample()
            action = self._process_action(action, n_groups, n_loan_allowed)

            params = self.state.params
            
            self.state.credit_thresholds, self.state.loan_approved, \
            self.state.loan_defaulted, self.state.loan_repaid \
                =  _update_state(
                    params.class_probs,
                    params.repay_probs,
                    params.dynamic_rate,
                    self.alphas,
                    self.state.credit_scores, 
                    action
                )
            obs = self._get_observable_state()
        
        return obs, {}

    def step(self, actions):
        if not self.action_space.contains(actions):
            raise gym.error.InvalidAction('Invalid action: %s' % actions)
        action = self._process_action(actions, self.state.params.n_groups, NUM_CLIENTS_PER_GROUP)

        real_state = self.state.params.class_probs # log before update
        # print("obs:      ", np.array(self.state.params.class_probs).round(3))
        self.state = self._step_impl(self.state, action)
        obs = self._get_observable_state()

        self.timestep += 1
        reward = self._reward_fn()
        self.state.inequality = self.rew_info['inequality_term']

        return obs, reward, False, self._is_truncated(), \
            {"cost": self.rew_info['inequality_term'], "real_state": real_state, \
             "max_rate": self.rew_info['max_rate'], "min_rate": self.rew_info['min_rate'], \
             "occurr": self.rew_info['occurr'], \
             "miss": self.rew_info['miss'], "alloc": self.rew_info['alloc']}
        
    def render(self):
        raise NotImplementedError

